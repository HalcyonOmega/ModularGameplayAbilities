// Copyright 2022-2024 Mickael Daniel. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Abilities/ModularGameplayAbility.h"

class UAttributeSet;
class UAbilitySystemComponent;
class AActor;
class UActorComponent;
class UMGAAbilitySet;
class UGameplayAbility;
class UGameplayEffect;
class UInputAction;
struct FActiveGameplayEffectHandle;
struct FComponentRequestHandle;
struct FMGAAbilitySetHandle;
struct FMGAGameFeatureAbilityMapping;
struct FMGAGameFeatureAttributeSetMapping;
struct FGameplayAbilitySpec;
struct FGameplayAbilitySpecHandle;
struct FGameplayTagContainer;

class MODULARGAMEPLAYABILITIES_API FMGAUtilities final
{
public:
	/** Strips out any trailing "_C" from Blueprint class names */
	static FString GetAttributeClassName(const UClass* Class);

	/** Strips out any trailing "_C" from Blueprint class names */
	static FString GetAttributeClassName(FString ClassName);

	/** In editor, this will filter out properties with meta tag "HideInDetailsView" or equal to InFilterMetaStr. In non editor, it returns all properties */
	static void GetAllAttributeProperties(TArray<FProperty*>& OutProperties, FString InFilterMetaStr = FString(), bool bInUseEditorOnlyData = true);

	/** Returns all properties in the given class that are valid Gameplay Attributes properties */
	static void GetAllAttributeFromClass(const UClass* InClass, TArray<FProperty*>& OutProperties, FString InFilterMetaStr = FString(), bool bInUseEditorOnlyData = true);

	/** Checks whether the attribute set class has to be considered to generate dropdown (filters out SKEL / REINST BP Class Generated By) */
	static bool IsValidAttributeClass(const UClass* Class);

	/**
	 * Returns whether given property "CPPType" is a valid type to consider for attributes
	 *
	 * Restricting to only FGameplayAttributeData and child of it (that we know of)
	 */
	static bool IsValidCPPType(const FString& InCPPType);

	/**
	 * Serialize helper for AttributeSets as a static for reuse.
	 *
	 * UAttributeSets that wish to implement serialization for save game (on saving / loading) can choose to use this
	 * method to serialize all of their FGameplayAttributes marked for SaveGame (with SaveGame UPROPERTY) into the
	 * Archive on Save, and read out of the Archive on Load by calling this method with Serialize().
	 *
	 * Usage:
	 * 
	 * ```cpp
	 * void UMyAttributeSet::Serialize(FArchive& Ar)
	 * {
	 * 	Super::Serialize(Ar);
	 *
	 * 	if (Ar.IsSaveGame())
	 * 	{
	 * 		FMGAUtilities::SerializeAttributeSet(this, Ar);
	 * 	}
	 * }
	 * ```
	 */
	static void SerializeAttributeSet(UAttributeSet* InAttributeSet, FArchive& InArchive);

	/**
	 * Serialize helper for AttributeSets as a static for reuse.
	 *
	 * Simply goes through each Spawned AttributeSet and calls Serialize on each AttributeSet.
	 * 
	 * Usage:
	 * 
	 * ```cpp
	 * void UMyAbilitySystemComponent::Serialize(FArchive& Ar)
	 * {
	 * 	Super::Serialize(Ar);
	 *
	 * 	if (Ar.IsSaveGame())
	 * 	{
	 * 		FMGAUtilities::SerializeAbilitySystemComponentAttributes(this, Ar);
	 * 	}
	 * }
	 * ```
	 */
	static void SerializeAbilitySystemComponentAttributes(const UAbilitySystemComponent* InASC, FArchive& InArchive);


	
	/* BREAK -------------------------------------------------- BREAK */

	/* Functions added from GSC */
		static void TryGrantAbility(UAbilitySystemComponent* InASC, const FMGAGameFeatureAbilityMapping& InAbilityMapping, FGameplayAbilitySpecHandle& OutAbilityHandle, FGameplayAbilitySpec& OutAbilitySpec);

	static void TryBindAbilityInput(
		UAbilitySystemComponent* InASC,
		const FMGAGameFeatureAbilityMapping& InAbilityMapping,
		const FGameplayAbilitySpecHandle& InAbilityHandle,
		const FGameplayAbilitySpec& InAbilitySpec,
		FDelegateHandle& OutOnGiveAbilityDelegateHandle,
		TArray<TSharedPtr<FComponentRequestHandle>>* OutComponentRequests = nullptr
	);
	
	static void TryGrantAttributes(UAbilitySystemComponent* InASC, const FMGAGameFeatureAttributeSetMapping& InAttributeSetMapping, UAttributeSet*& OutAttributeSet);
	static void TryGrantGameplayEffect(UAbilitySystemComponent* InASC, const TSubclassOf<UGameplayEffect> InEffectType, const float InLevel, TArray<FActiveGameplayEffectHandle>& OutEffectHandles);
	static bool TryGrantAbilitySet(UAbilitySystemComponent* InASC, const UMGAAbilitySet* InAbilitySet, FMGAAbilitySetHandle& OutAbilitySetHandle, TArray<TSharedPtr<FComponentRequestHandle>>* OutComponentRequests = nullptr);
	
	/** Helper to return the AttributeSet UObject as a non const pointer, if the passed in ASC has it granted */
	static UAttributeSet* GetAttributeSet(const UAbilitySystemComponent* InASC, const TSubclassOf<UAttributeSet> InAttributeSet);

	/** Determine if a gameplay effect is already applied, same class and same level */
	static bool HasGameplayEffectApplied(const UAbilitySystemComponent* InASC, const TSubclassOf<UGameplayEffect>& InEffectType, TArray<FActiveGameplayEffectHandle>& OutEffectHandles);

	/** Determine if an ability is already granted, same class and same level */
	static bool IsAbilityGranted(const UAbilitySystemComponent* InASC, TSubclassOf<UGameplayAbility> InAbility, const int32 InLevel = 1);

	// Commented out due to a "use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension" warning only on linux 5.0 with strict includes
	
	// template<class ComponentType>
	// static ComponentType* FindOrAddComponentForActor(AActor* InActor, TArray<TSharedPtr<FComponentRequestHandle>>& OutComponentRequests)
	// {
	// 	return Cast<ComponentType>(FindOrAddComponentForActor(ComponentType::StaticClass(), InActor, OutComponentRequests));
	// }
	static UActorComponent* FindOrAddComponentForActor(UClass* InComponentType, const AActor* InActor, TArray<TSharedPtr<FComponentRequestHandle>>& OutComponentRequests);

	/** Adds a tag container to ASC, but only if ASC doesn't have said tags yet */
	static void AddLooseGameplayTagsUnique(UAbilitySystemComponent* InASC, const FGameplayTagContainer& InTags, const bool bReplicated = true);
	
	/** Removes a tag container to ASC, but only if ASC doesn't have said tags yet */
	static void RemoveLooseGameplayTagsUnique(UAbilitySystemComponent* InASC, const FGameplayTagContainer& InTags, const bool bReplicated = true);

private:
	/** Handler for AbilitySystem OnGiveAbility delegate. Sets up input binding for clients (not authority) when GameFeatures are activated during Play. */
	/* @TODO: Fix or cleanup
	 * static void HandleOnGiveAbility(
		FGameplayAbilitySpec& InAbilitySpec,
		TWeakObjectPtr<UGSCAbilityInputBindingComponent> InInputComponent,
		TWeakObjectPtr<UInputAction> InInputAction,
		const EModularAbilityActivationGroup InTriggerEvent,
		FGameplayAbilitySpec InNewAbilitySpec
	);*/
};
